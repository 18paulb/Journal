import {
    S3Client,
    PutObjectCommand,
    GetObjectCommand,
    ListObjectsCommand
} from "@aws-sdk/client-s3";


const bucketName = 'journalappphotos'


const s3Client = new S3Client({});


export async function uploadPhoto(image, email, today) {
    const year = today.getFullYear();
    const month = today.getMonth() + 1; // Gets the month (0-based, so add 1)
    const day = today.getDate();

    const key = `${email}/${year}/${month}/${day}/${image.originalname}`

    const input = {
        Bucket: bucketName,
        Key: key,
        Body: image.buffer,
        ContentType: image.mimetype
    }

    try {
        let command = new PutObjectCommand(input)
        const response = await s3Client.send(command)
        console.log(response)
    } catch (error) {
        console.log(error)
    }
}

export async function getPhotosForJournalEntry(email, date) {
    const year = date.getFullYear();
    const month = date.getMonth() + 1; // Gets the month (0-based, so add 1)
    const day = date.getDate(); 


    const input = { // ListObjectsRequest
        Bucket: bucketName, // required
        Prefix: `${email}/${year}/${month}/${day}/`,
    };
    const command = new ListObjectsCommand(input);
    const response = await s3Client.send(command);

    let photos = response.Contents

    // This was all generated by AI, while it works I haven't verified what this is doing in terms of the Buffer
    // Make sure to double check
    if (photos) {

        // Loop through the objects and get the image data
        const fetchPromises = photos.map(async (item) => {
            const imageKey = item.Key;

            const getObjectParams = {
                Bucket: bucketName,
                Key: imageKey,
            };

            const getObjectCommand = new GetObjectCommand(getObjectParams);
            const imageResponse = await s3Client.send(getObjectCommand);

            // If you want the image data as a Buffer
            const stream = imageResponse.Body; // This is a ReadableStream
            const chunks = [];

            for await (const chunk of stream) {
                chunks.push(chunk);
            }
            const imageBuffer = Buffer.concat(chunks);

            // Now you have the image data in imageBuffer (you can use this for further processing)
            return { imageKey, imageBuffer };
        });

        // Wait for all images to be fetched
        const imagesData = await Promise.all(fetchPromises);

        return imagesData

    } else {
        console.log("No objects found with the specified prefix.");
        return []
    }
}